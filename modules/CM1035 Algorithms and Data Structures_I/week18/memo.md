# Week 18: ソートアルゴリズムの計算量比較

## 1. クイックソートの最悪時間計算量：O(n²)

### 最悪ケース：毎回ピボットが最大値（または最小値）

```
[4, 8, 7, 9, 5]  pivot=9 → 全部左へ、1つしか減らない
[4, 8, 7, 5]      pivot=8 → 同様
[4, 7, 5]          pivot=7 → 同様
...

比較回数: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)
```

- ベクトルが2つに分割されず、**1つずつしか減らない**
- Decrease and Conquer と同じ状態に退化する

### しかし最悪ケースは稀

- 典型的な入力ではほぼ半分に分割される
- **平均計算量は O(n log n)**
- そのため実務で広く使われている（JavaScript、各種ライブラリ）

---

## 2. マージソートの最悪時間計算量：O(n log n)

### なぜ常に O(n log n) か

- 分割は値に**依存しない**（常に位置で半分に切る）
- **全ての入力に対して同じ動作**をする（最悪 = 平均）

```
半分にする回数: O(log n)
各段階のマージ操作: O(n)
合計: O(n × log n) = O(n log n)
```

※ より厳密な導出には漸化式とマスター定理（Master Theorem）を使う（本モジュール範囲外）

---

## 3. 空間計算量（Space Complexity）

**アルゴリズムが追加で必要とするメモリ量**

### 各アルゴリズムの空間計算量

**バブルソート・挿入ソート：O(1)**
- スワップ用の一時変数とインデックスのみ
- 入力サイズに関係なく一定

**クイックソート：O(log n)**
- in-place（元の配列上でスワップ）→ 新しい配列不要
- 再帰のコールスタック分のみ（最大 log n 段）
- tail recursion 最適化で改善可能

**マージソート：O(n)**
- マージのたびに新しい配列を作成する必要がある
- 最大 n 個分の追加メモリ

### なぜクイックソートとマージソートで違うのか

| | やり方 | 追加メモリ |
|--|--|--|
| クイックソート | 元の配列内でスワップ（in-place） | コールスタック分だけ |
| マージソート | 新しい配列にコピーしてマージ | n個分の配列が必要 |

---

## 4. 総合比較表（暗記必須！）

| アルゴリズム | 最悪時間計算量 | 平均時間計算量 | 最悪空間計算量 |
|--|--|--|--|
| バブルソート | O(n²) | O(n²) | O(1) |
| 挿入ソート | O(n²) | O(n²) | O(1) |
| クイックソート | O(n²) | **O(n log n)** | O(log n) |
| マージソート | **O(n log n)** | **O(n log n)** | O(n) |

### 使い分けの指針

- **時間が重要** → クイックソート / マージソート
- **メモリが重要** → バブルソート / 挿入ソート
- **最悪ケースを保証したい** → マージソート
- **平均的に速い + メモリ節約** → クイックソート

---

## 5. データ構造による違い

| | ベクトル/配列 | 連結リスト |
|--|--|--|
| マージソートの空間計算量 | O(n) | **O(1)** |
| クイックソート | 向いている | 向いていない |

連結リストではポインタの付け替えだけでマージできるため、マージソートの空間計算量が O(1) に改善される。

---

## 6. 補足：実際のプログラミング言語でのソート

| 言語/エンジン | ソートアルゴリズム |
|--|--|
| JavaScript (V8/Chrome) | TimSort |
| JavaScript (Firefox) | マージソート |
| Python | TimSort |
| Java | Dual-Pivot QuickSort / TimSort |

**TimSort** = マージソート + 挿入ソートのハイブリッド。実世界のデータに最適化。

---

## 7. トピック最終問題：数独パズル

### 力任せ（Brute Force）の解法

空白マスが B 個ある場合：

| パズル | 候補の数 |
|--|--|
| 4×4 | 最大 4^B 通り |
| 9×9 | 最大 9^B 通り |

→ **指数的な計算量** — 非常に遅い

### 改善のアプローチ：バックトラッキング

- 1マスずつ数字を入れていく
- 制約違反が見つかったら**即座に戻る**（全候補を試さない）
- 枝刈り（pruning）で探索空間を大幅に削減

---

## 8. 重要ポイントまとめ

1. **クイックソート最悪 O(n²)**：ピボットが毎回最大/最小値のとき
2. **マージソート最悪 O(n log n)**：入力に依存しない（常に同じ）
3. **空間計算量**：クイックソート O(log n) < マージソート O(n)
4. **万能なアルゴリズムはない**：速さとメモリのトレードオフ
5. **データ構造で最適解が変わる**：連結リストならマージソート O(1) 空間
6. **比較ベースソートの理論的限界**：O(n log n) が下限

---

## 練習問題と解答

### Q1: 最悪時間計算量の観点で、バブルソートと挿入ソートどちらを使うべき？
**A:** どちらも同じ（両方 O(n²)）

### Q2: 最悪時間計算量の観点で、クイックソートと挿入ソートどちらを使うべき？
**A:** どちらも同じ（両方最悪 O(n²)）

### Q3: 最悪時間計算量の観点で、マージソートとクイックソートどちらを使うべき？
**A:** マージソート（O(n log n) vs O(n²)）

### Q4: 空間計算量の観点で、ベクトルに対してマージソートとクイックソートどちらを使うべき？
**A:** クイックソート（O(log n) vs O(n)）
