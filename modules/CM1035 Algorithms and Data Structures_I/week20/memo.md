# Week 20: NP完全問題のアプローチと計算モデルの展望

## 1. NP完全問題への一般的アプローチ

NP完全問題には効率的なアルゴリズムが存在しないと考えられているが、それでも解くための一般的手法がある。

### 全候補探索（Brute Force / Enumeration）

- 全ての候補解（proof / certificate）を1つずつ試す
- **線形探索と同じ考え方**：指数的に大きな「ベクトル」を端から順に調べる
- 証拠は多項式サイズだが、候補の数は **O(2^多項式)** → 指数的
- 実際にベクトルを構築する必要はない（各候補をその場で計算・検証すればよい）

```
線形探索: ベクトルの全要素を順番に調べる → O(n)
NP完全: 指数的に大きな候補空間を順番に調べる → O(2^多項式)
```

### 二分探索はNP完全問題に使えるか？

| 探索手法 | ベクトルサイズ n に対する計算量 | 指数サイズ 2^k のベクトルなら |
|--|--|--|
| 線形探索 | O(n) | O(2^k) → 指数時間 |
| 二分探索 | O(log n) | O(log 2^k) = O(k) → **多項式時間** |

もし候補解の空間に二分探索を適用できたら、NP完全問題が多項式時間で解ける → **P = NP**

- P = NP はありそうにない → **NP完全問題には二分探索は適用できない**
- 候補解が「ソート済み」のような構造を持たないため

### 二分探索が有効な例：完全平方数判定

```
問題: n は完全平方数か？
方法: 0 から n までの整数の2乗を「仮想的な配列」として二分探索

i²  = [0, 1, 4, 9, 16, 25, ...]  ← ソート済み！
     ↑ この中に n があるか？

配列サイズは n+1、二分探索で O(log n) → 入力サイズに対して線形時間
配列を実際に作る必要はない（mid² をその場で計算するだけ）
```

---

## 2. バックトラッキング（Backtracking）

### 基本的な考え方

- 候補解を1つずつ値を決めていく
- **制約違反が見つかったら、前の選択に戻って別の値を試す**
- 迷路探索（Topic 4）でスタックを使って行き止まりから戻るのと同じ原理

### 数独でのバックトラッキング（スタック使用）

```
4×4 数独の空白マスを埋める例:

Step 1: 空白マス①に候補 {1, 4} → 1 を選択、スタックに PUSH[1]
        スタック: [1]

Step 2: 空白マス②に候補 {1, 3, 4} → 1は使用済み → 3 を選択、PUSH[3]
        スタック: [3, 1]

Step 3: 空白マス③に候補 {4} のみ → しかし同じ行に 4 が既にある → 矛盾！
        → POP[スタック]（3 を取り出す）
        → 空白マス②を 4 に変更、PUSH[4]
        スタック: [4, 1]

Step 4: 空白マス③を再試行 → 3 が入る → 成功！ PUSH[3]
        スタック: [3, 4, 1]

... 以降同様に続ける
```

### 再帰による実装

- バックトラッキングは通常**再帰**で実装される
- **コールスタック**が自動的にバックトラッキングの役割を果たす
- 明示的なスタックを使う方法と原理は同じ

### バックトラッキングの特徴

| 特徴 | 説明 |
|--|--|
| 枝刈り（Pruning） | 制約違反を早期発見し、無駄な探索を省く |
| 最悪計算量 | 依然として指数的（全候補を試す場合） |
| 平均的な効果 | 枝刈りにより実際の探索数を大幅に削減 |
| データ構造 | スタック（明示的またはコールスタック） |

---

## 3. 計算モデルとその展望

### 計算モデルの等価性

- **RAMモデル**とチューリングマシンは計算能力がほぼ等価
- モデル間の変換で追加操作が生じるが、**多項式の範囲内**に収まる
- → 「効率的 = 多項式時間」という定義がモデルに依存しない

### 乱択アルゴリズム（Randomised Computation）

- 乱数を使って次の操作を確率的に決定する
- 用途：科学シミュレーション、暗号技術
- 計算複雑性の観点では**劇的な改善にはならない**
- 多くの研究者は「乱択でできることは非乱択でもできる」と考えている

### 量子コンピューティング（Quantum Computing）

- 量子物理学のルールに基づく情報処理 → 根本的に異なるアプローチ
- RAMモデルでは量子コンピュータを効率的にシミュレートできない

| 特徴 | 古典コンピュータ | 量子コンピュータ |
|--|--|--|
| 未ソート配列の探索 | O(n)（線形探索） | O(√n)（グローバーのアルゴリズム） |
| 整数の素因数分解 | 指数時間 | 多項式時間（ショアのアルゴリズム） |
| 暗号への影響 | — | 現在の暗号を破る可能性 |

→ 新しいアルゴリズムとデータ構造の開発が必要な分野

---

## 4. モジュール全体の振り返り

### 前半（基礎）

| トピック | 内容 |
|--|--|
| 問題とアルゴリズム | 問題の定義、アルゴリズムの概念 |
| 記述方法 | フローチャート、擬似コード、相互変換 |
| 線形データ構造 | ベクトル、スタック、キュー（抽象）/ 配列、連結リスト、動的配列（具体） |
| 基本アルゴリズム | 線形探索、バブルソート、挿入ソート |
| 性能比較 | Big O 記法、計算量の理論 |

### 後半（応用）

| トピック | 内容 |
|--|--|
| 探索アルゴリズム | 二分探索（O(log n)） |
| 高速ソート | クイックソート、マージソート（O(n log n)） |
| 再帰 | Decrease and Conquer、Divide and Conquer |
| 計算複雑性 | P, NP, EXP, NP-Complete, P vs NP |
| 展望 | 乱択アルゴリズム、量子コンピューティング |

---

## 5. 重要ポイントまとめ

1. **全候補探索**：NP完全問題を線形探索的に解く → 指数時間
2. **二分探索の限界**：もし候補空間に適用できれば P = NP → ありそうにない
3. **バックトラッキング**：スタックで選択を記録し、行き詰まったら戻る
4. **計算モデルの等価性**：RAMモデルとチューリングマシンは多項式の範囲で等価
5. **乱択アルゴリズム**：劇的な改善にはならないと考えられている
6. **量子コンピュータ**：線形探索を O(√n) に改善、暗号を破る可能性

---

## 練習問題と解答

### Q1: NP完全問題に対する全候補探索の計算量は？
**A:** 指数時間。候補解の数が指数的（O(2^多項式)）で、それぞれを検証する必要があるため

### Q2: なぜ二分探索はNP完全問題に使えないのか？
**A:** もし使えたら、指数サイズの候補空間を O(log(指数)) = O(多項式) で探索でき、P = NP が成立してしまう。P = NP はありそうにないため、二分探索は適用できないと考えられる

### Q3: バックトラッキングで使われるデータ構造は？
**A:** スタック。選択をPUSHし、行き詰まったらPOPして前の選択に戻る。再帰実装ではコールスタックが同じ役割を果たす

### Q4: 量子コンピュータが未ソート配列を探索する計算量は？
**A:** O(√n)（グローバーのアルゴリズム）。古典的な線形探索の O(n) より高速

### Q5: 乱択アルゴリズムはNP完全問題を効率的に解けるか？
**A:** いいえ。乱択アルゴリズムは劇的な改善にはならないと考えられており、多くの研究者は乱択でできることは非乱択でもできると考えている
