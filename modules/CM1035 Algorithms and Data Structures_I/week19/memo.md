# Week 19: 計算複雑性理論（Computational Complexity）と P vs NP

## 1. 導入：数独パズルの改善

### 力任せ（Brute Force）の問題点

4×4 数独で空白マスが B 個ある場合、最大 **4^B 通り** の候補を試す必要がある。
9×9 では **9^B 通り** → 指数的に爆発し、非現実的。

### バックトラッキング（Backtracking）による改善

- 1マスずつ数字を入れていく
- **制約違反が見つかった時点で即座に戻る**（枝刈り / pruning）
- 全候補を試さずに探索空間を大幅に削減
- しかし最悪ケースでは依然として指数的

**→ 数独は「解くのは難しいが、答えの検証は簡単」な問題の代表例**

---

## 2. 計算複雑性の基礎

### 効率的 vs 非効率的

| | 効率的（Efficient） | 非効率的（Inefficient） |
|--|--|--|
| 計算量 | 多項式時間（Polynomial） | 指数時間（Exponential） |
| 例 | O(n), O(n²), O(n log n) | O(2ⁿ), O(n!), O(9^B) |
| 特徴 | 入力が大きくても現実的 | 入力が少し増えるだけで爆発 |

### 入力サイズの統一表現

- 全ての入力は**ビット列（binary string）** として表現できる
- 入力サイズ = ビット列の長さ
- 例：整数 13 → `1101`（4ビット）、文字列 → ASCII/UTF-8のビット列

### 多項式時間（Polynomial Time）とは

計算量が入力サイズ n の多項式で表せること：

```
O(n), O(n²), O(n³), O(n^k) ... いずれも多項式時間
O(2ⁿ), O(n!) ... 指数時間（多項式時間ではない）
```

**ポイント：** O(n²) は遅いが「効率的」に分類される。多項式 vs 指数の壁が重要。

---

## 3. 決定問題（Decision Problem）と言語（Language）

### 決定問題とは

- **Yes / No で答えられる問題**
- 入力：ビット列、出力：Yes または No

### 言語（Language）

- ある決定問題に対して **Yes を返す全ての入力の集合**
- 例：「n は完全平方数か？」→ 言語 = {0, 1, 4, 9, 16, 25, ...}（のビット列表現）

```
決定問題「n は完全平方数か？」
  入力 4  → Yes（√4 = 2 は整数）
  入力 5  → No（√5 は整数でない）
  入力 9  → Yes（√9 = 3 は整数）

言語 = { Yes を返す入力の集合 } = {0, 1, 4, 9, 16, 25, ...}
```

### 最適化問題との関係

- 「最短経路は何か？」→ 最適化問題（決定問題ではない）
- 「長さ k 以下の経路は存在するか？」→ 決定問題に変換可能

---

## 4. 計算複雑性クラス（Complexity Classes）

### 複雑性クラスとは

- **決定問題の集合**（= 言語の集合 = 集合の集合）
- 同じ計算リソースの制約で解ける問題をまとめたグループ

### クラス P（Polynomial Time）

**定義：** 多項式時間で**解ける**決定問題の集合

```
P = { 多項式時間アルゴリズムが存在する決定問題 }
```

例：
- 「n は完全平方数か？」→ O(log n) で判定可能 → **P に属する**
- 「配列はソート済みか？」→ O(n) で判定可能 → **P に属する**
- 「n は素数か？」→ AKS素数判定法で多項式時間 → **P に属する**
- 線形探索、二分探索、各種ソートに関する判定問題 → **P に属する**

### クラス EXP（Exponential Time）

**定義：** 指数時間で解ける決定問題の集合

```
EXP = { 指数時間アルゴリズムが存在する決定問題 }
```

**重要な関係：P ⊂ EXP**（P は EXP の真部分集合）

- P で解ける問題は全て EXP でも解ける（多項式時間は指数時間の範囲内）
- しかし EXP には P で解けない問題が存在する

---

## 5. クラス NP（Nondeterministic Polynomial Time）

### 定義

**「証拠（proof / certificate）が与えられれば、多項式時間で検証できる」決定問題の集合**

```
NP = { 証拠があれば多項式時間で Yes と検証できる決定問題 }
```

### 数独での具体例

| 操作 | 計算量 | 説明 |
|--|--|--|
| 解く（solve） | 指数的 | 全候補を探索する必要がある |
| 検証する（verify） | 多項式的 | 各行・列・ブロックをチェックするだけ |

- 数独の解答（= 証拠）が与えられれば、正しいかどうかは**すぐ確認**できる
- しかし解答を**見つける**のは非常に難しい
- → 数独は **NP** に属する

### P と NP の関係

```
P ⊆ NP ⊆ EXP
```

- **P ⊆ NP**：多項式時間で解ける問題は、当然多項式時間で検証もできる（解くこと自体が検証になる）
- **NP ⊆ EXP**：NP の問題は最悪でも指数時間で解ける（全ての証拠を試せばよい）

---

## 6. NP困難（NP-Hard）と NP完全（NP-Complete）

### NP-Hard（NP困難）

**定義：** NP に属する**全ての問題**を多項式時間で帰着（reduction）できる問題

- 「NP の中で最も難しい問題と同じかそれ以上に難しい」
- NP-Hard は NP に属するとは限らない（決定問題でない場合もある）

### NP-Complete（NP完全）

**定義：** NP-Hard **かつ** NP に属する問題

```
NP-Complete = NP-Hard ∩ NP
```

- NP の中で**最も難しい**問題
- 例：数独、巡回セールスマン問題（決定版）、SAT問題

### NP完全の重要な性質

もし**1つでも** NP完全問題が多項式時間で解ければ → **全ての NP 問題**が多項式時間で解ける → **P = NP**

---

## 7. P vs NP 問題

### 未解決の大問題

**「P = NP か？ P ≠ NP か？」**

- クレイ数学研究所の**ミレニアム懸賞問題**（賞金100万ドル）
- 2000年に提示され、現在も未解決

### もし P = NP なら

- NP の全ての問題（数独、暗号解読、スケジューリングなど）が効率的に解ける
- 現代の暗号技術が崩壊する
- 多くの研究者は **P ≠ NP** だと考えている（が証明されていない）

### 関係図

```
P = NP の場合:          P ≠ NP の場合（多くの研究者の予想）:

┌─── EXP ────┐          ┌──── EXP ─────┐
│             │          │               │
│  ┌─ NP ──┐ │          │  ┌── NP ───┐  │
│  │        │ │          │  │          │  │
│  │   P    │ │          │  │ NP-C     │  │
│  │        │ │          │  │   ┌──┐   │  │
│  └────────┘ │          │  │   │  │   │  │
│             │          │  │   └──┘   │  │
└─────────────┘          │  │  ┌───┐   │  │
                         │  │  │ P │   │  │
                         │  │  └───┘   │  │
                         │  └──────────┘  │
                         └────────────────┘
```

---

## 8. 停止問題（Halting Problem）

- 「あるプログラムが有限時間で停止するか？」という決定問題
- アラン・チューリングが**決定不能（undecidable）** であることを証明
- **どんなアルゴリズムでも解けない**（P にも NP にも EXP にも属さない）
- 計算可能性の限界を示す重要な結果

---

## 9. Revision PDF からの重要ポイント

### Part A: 基礎知識の確認

**擬似コードの読解（Question a）：**
```
a ← 2
a ← a³        → a = 8
smallerThan(8) → 8 < 10 なので 8 を返す → a = 8
a ← a + 1     → a = 9
smallerThan(9) → 9 < 10 なので 9 を返す → a = 9
```

**フローチャート（Question c）：** ユークリッドの互除法（GCD）
- a = b になるまで、大きい方から小さい方を引き続ける
- 最大公約数を求めるアルゴリズム

**データ構造の選択（Question d, e）：**
- 動的配列 vs スタック：アクセス方法が異なる（ランダム vs LIFO）
- 順番にタスクをこなす → **キュー**（FIFO: First In, First Out）が適切

**キュー操作（Question f）：**
```
ENQUEUE[10, q]    → q: [10]
store ← HEAD[q]   → store = 10
ENQUEUE[5, q]     → q: [10, 5]
DEQUEUE[q]        → q: [5]（10が取り出される）
store ← store + HEAD[q] → store = 10 + 5 = 15
```

**Big O 記法（Question i）：**
- アルゴリズム A: 0.01N² + 2N + 4 → **O(N²)**
- アルゴリズム B: 1000N log₂(N) + 2N → **O(N log N)**
- N が大きくなると B の方が高速 → **アルゴリズム B を選ぶべき**
- 定数係数（0.01 や 1000）は Big O では無視される

**フィボナッチの再帰（Question j）：**
```
function fibonacci(n):
    if n == 0: return 0      ← ベースケース1
    if n == 1: return 1      ← ベースケース2
    return fibonacci(n-1) + fibonacci(n-2)  ← 再帰ケース
```

### Part B: 応用問題

**クイックソートの手動実行（Question 1a）：**
```
S = [0, 1, 16, 4, 9, 25]

pivot = S[floor((0+5)/2)] = S[2] = 16
→ 分割: [0, 1, 4, 9] と [25]、pivot=16は中間

左側 [0, 1, 4, 9]: pivot = S[floor((0+3)/2)] = S[1] = 1
→ 分割: [0] と [4, 9]、pivot=1は中間

[4, 9]: pivot = S[floor((0+1)/2)] = S[0] = 4
→ 分割: [] と [9]、pivot=4は中間

マージ: [0, 1, 4, 9, 16, 25]
```

**二分探索の手動実行（Question 1b）：**
```
ソート済み S = [0, 1, 4, 9, 16, 25]、探す値 = 2

Step 1: mid = floor((0+5)/2) = 2 → S[2] = 4 > 2 → 左半分を探索
Step 2: mid = floor((0+1)/2) = 0 → S[0] = 0 < 2 → 右半分を探索
Step 3: mid = floor((1+1)/2) = 1 → S[1] = 1 < 2 → 右半分を探索
Step 4: 探索範囲が空 → 2 は見つからない → false
```

**二分探索の最悪計算量：O(log n)**

**線形探索の実装（Question 1d）：**
```javascript
function linearSearch(a, n) {
    for (var i = 0; i < a.length; i++) {
        if (a[i] === n) return true;
    }
    return false;
}
```

**二分探索による完全平方数判定（Question 1e）：**
```javascript
function intBin(n) {
    var low = 0;
    var high = n;
    while (low <= high) {
        var mid = Math.floor((low + high) / 2);
        if (mid * mid === n) return true;
        else if (mid * mid < n) low = mid + 1;
        else high = mid - 1;
    }
    return false;
}
// 配列を作らず O(log n) で判定できる
```

**再帰関数（Question 2）：**
```javascript
// 再帰的な合計
function recSum(n) {
    if (n <= 0) return 0;
    return n + recSum(n - 1);
}

// 再帰的な階乗
function recFactorial(n) {
    if (n <= 0) return 1;
    return n * recFactorial(n - 1);
}
// 計算量: O(n) — n回の再帰呼び出し、各回で定数時間の操作
```

**FactorialStack の MISSING 部分（Question 2e）：**
```
PUSH[i × TOP[s], s]
```
→ FactorialStack(4) の TOP[f] = **24**（4! = 24）

**連結リストの構築と探索（Question 3）：**
```javascript
// スタック [5, 2, 1] の連結リスト構築
var head = new LLNode(5);
head.next = new LLNode(2);
head.next.next = new LLNode(1);

// 連結リストの線形探索
function searchLL(list, item) {
    var current = list;
    while (current !== null) {
        if (current.data === item) return true;
        current = current.next;
    }
    return false;
}
```

---

## 10. 重要ポイントまとめ

1. **決定問題**：Yes/No で答える問題。言語 = Yes を返す入力の集合
2. **P**：多項式時間で解ける問題の集合（効率的に解ける）
3. **NP**：証拠があれば多項式時間で検証できる問題の集合
4. **EXP**：指数時間で解ける問題の集合
5. **P ⊆ NP ⊆ EXP**：包含関係
6. **NP-Complete**：NP の中で最も難しい問題（NP-Hard ∩ NP）
7. **P vs NP**：未解決。1つの NP-Complete 問題が P に属すれば P = NP
8. **停止問題**：決定不能（どのクラスにも属さない）
9. **Big O 記法**：定数係数を無視し、最も支配的な項のみを評価

---

## 練習問題と解答

### Q1: NP に属する問題とは？
**A:** 答えの「証拠」が与えられれば、多項式時間でその正しさを検証できる決定問題

### Q2: P = NP が証明されたらどうなる？
**A:** NP の全ての問題が多項式時間で解けることになる。現代の暗号技術が崩壊する可能性がある

### Q3: 数独はどの複雑性クラスに属する？
**A:** NP-Complete。解くのは指数的だが、解の検証は多項式時間で可能。かつ NP の他の問題を数独に帰着できる

### Q4: 「完全平方数か？」と「素数か？」は同じ複雑性クラスに属するか？
**A:** はい。どちらも P に属する（多項式時間で判定可能）

### Q5: 0.01N² + 2N + 4 の Big O は？
**A:** O(N²)。Big O では定数係数と低次の項は無視する

### Q6: 二分探索の最悪時間計算量は？
**A:** O(log n)。毎回探索範囲が半分になるため

### Q7: recFactorial(n) の計算量は？
**A:** O(n)。n 回の再帰呼び出しがあり、各呼び出しで定数時間の操作（掛け算1回）を行う
