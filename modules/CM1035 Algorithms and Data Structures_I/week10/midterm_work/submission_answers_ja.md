# CM1035 中間テスト - 提出用回答

## 質問1: ソリューションの本質 (10点)

私のPoetry Assistantは、**接尾辞ベースのマッチングアルゴリズム**を使用して韻を踏む単語を検索します。「cat」のような単語を入力すると、「bat」「hat」「rat」「acrobat」など、同じ末尾を持つ単語を返します。

ソリューションの仕組み：
1. **前処理**: すべての単語から接尾辞-単語ペアの配列を構築
2. **クエリ**: 線形探索を使用して入力単語と同じ接尾辞を持つ単語を検索

このアプローチは、このコースで扱われている配列と線形探索のみを使用しています。

---

## 質問2: アルゴリズムの説明 (10点)

### オリジナリティについて

このアルゴリズムは、既存の韻検索ライブラリやAPIを使用せず、ゼロから設計しました。接尾辞マッチングのアプローチは、韻を踏む単語を見つけるための独自の設計選択です。

### アルゴリズムの動作（非技術的な説明）

1. プログラム起動時に、単語リストからすべての単語を読み込み、各単語について（接尾辞、単語）のペアを作成します。例えば「cat」からは、("t", "cat")、("at", "cat")、("cat", "cat")というペアが作成されます。

2. ユーザーが「cat」のような単語を入力すると、プログラムはその単語の可能な末尾を調べます：「t」、「at」、「cat」。

3. 各末尾について、プログラムはすべての接尾辞-単語ペアを検索し、同じ末尾を持つ単語を見つけます。

4. プログラムはこれらの結果を統合し、線形探索で重複を除去して、元の入力単語を除外してユーザーに返します。

このアプローチは、このコースで扱われている配列と線形探索のみを使用しています。

---

## 質問3: 擬似コード (20点)

Cormen et al. 第2章の規約に従う：

### 接尾辞インデックスの構築

```
BUILD-SUFFIX-INDEX(words)
 1  suffixPairs = new Array
 2  for i = 1 to words.length
 3      word = words[i]
 4      for j = 1 to word.length
 5          suffix = SUBSTRING(word, word.length - j + 1, word.length)
 6          APPEND(suffixPairs, [suffix, word])
 7  return suffixPairs
```

### 韻の検索

```
FIND-RHYMES(suffixPairs, inputWord, minSuffixLength)
 1  results = new Array
 2  for j = minSuffixLength to inputWord.length
 3      targetSuffix = SUBSTRING(inputWord, inputWord.length - j + 1, inputWord.length)
 4      for i = 1 to suffixPairs.length
 5          [suffix, word] = suffixPairs[i]
 6          if suffix == targetSuffix and word ≠ inputWord
 7              if not LINEAR-SEARCH(results, word)
 8                  APPEND(results, word)
 9  return results
```

### 線形探索

```
LINEAR-SEARCH(A, target)
 1  for i = 1 to A.length
 2      if A[i] == target
 3          return true
 4  return false
```

---

## 質問4: データ構造 (20点)

### 4.1 配列（動的配列）

**構造:** 接尾辞-単語ペアと結果を格納する順序付きリスト。

```javascript
[
    ["t", "cat"],
    ["at", "cat"],
    ["cat", "cat"],
    ["t", "bat"],
    ["at", "bat"],
    ...
]
```

**適している理由:**
- **コースで扱われている:** 配列はこのコースで教えられている基本的なデータ構造
- **シンプルな保存:** すべての接尾辞-単語ペアを分かりやすい方法で保持
- **簡単な反復処理:** 線形探索を使用した順次処理が可能
- **動的サイズ調整:** インデックス構築時に必要に応じて拡張可能

### 4.2 線形探索

**アルゴリズム:** 配列内を順次検索してターゲット値を見つける。

**適している理由:**
- **コースで扱われている:** 線形探索はこのコースで教えられている基本的なアルゴリズム
- **シンプルな実装:** 理解しやすく、正しく実装しやすい
- **ソート不要:** 接尾辞ペアを事前にソートする必要がない

---

## 質問5: JavaScript実装 (20点)

添付ファイル参照: `rhyme-finder.js`

実装の主なポイント：
- Node.jsを使用、`fs`でファイル読み込み、`readline`でインタラクティブ入力
- `buildSuffixIndex()`: [接尾辞, 単語]ペアの配列を作成
- `findRhymes()`: 線形探索でマッチする単語を検索し、重複をチェック
- 継続的なクエリのためのインタラクティブCLIループ

---

## 質問6: デモ動画 (10点)

添付の動画ファイルで以下をデモ：
1. プログラムの起動と単語リストの読み込み
2. 様々な単語での韻検索（例：「cat」「love」「night」）
3. 検索時間付きの結果表示
4. プログラムの終了

---

## 質問7: 欠陥と改善点 (10点)

### 現在の欠陥/制限事項

1. **スペリングベースの韻のみ:** アルゴリズムは発音ではなくスペリングで単語の末尾を照合する。「love」と「move」は見た目は似ているが実際には韻を踏まない。

2. **ランキングなし:** 結果は韻の質（完全な韻 vs 不完全な韻）や有用性でランク付けされない。

3. **大きな結果セット:** 「-ing」のような一般的な接尾辞は数千のマッチを返し、ユーザーを圧倒する可能性がある。

4. **線形探索のオーバーヘッド:** 韻の検索と重複チェックの両方に線形探索を使用しているため、ハッシュベースのアプローチと比較してオーバーヘッドがある。

### 改善の可能性

1. **発音照合:** 発音に基づいて真の韻を見つけるために、音声アルゴリズム（SoundexやCMU発音辞書など）を使用する。

2. **結果ランキング:** 接尾辞の長さ（長いマッチ = より良い韻）や単語頻度で結果をランク付けし、一般的な単語を優先する。

3. **結果制限:** ユーザーが最大結果数を指定したり、単語長でフィルタリングできるようにして、出力を管理しやすくする。

4. **ハッシュベースのデータ構造の使用:** より大きなデータセットでは、HashMapとSetを使用することでO(n)の線形探索ではなくO(1)のルックアップ時間を提供できる。

---

## 時間・空間計算量

### 時間計算量
- **前処理（インデックス構築）:** O(n × m)、n = 単語数、m = 平均単語長
- **クエリ（韻検索）:** O(m × p × r)、m = 入力単語長、p = 接尾辞ペア数、r = 結果数

### 空間計算量
- **接尾辞ペア配列:** O(n × m)、各単語がm個の接尾辞-単語ペアを生成するため
