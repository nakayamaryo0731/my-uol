# 詩作アシスタント - 設計書

## 1. 概要

この詩作アシスタントは、詩人が韻を踏む単語を見つける手助けをします。入力された単語に対して、単語の末尾（接尾辞）が一致する韻を踏む単語のリストを返します。

**例：**
- 入力: `cat`
- 出力: `bat, hat, rat, acrobat, thermostat, ...`

---

## 2. オリジナルアルゴリズム

### 韻検索アルゴリズム

このアルゴリズムは、既存の韻検索ライブラリやAPIを使用せず、ゼロから設計しました。接尾辞マッチングのアプローチは、韻を踏む単語を見つけるための独自の設計選択です。

このアルゴリズムは、入力単語の接尾辞（末尾）を辞書内の他の単語と照合することで韻を見つけます。

**動作の仕組み（非技術的な説明）：**

1. プログラム起動時に、単語リストからすべての単語を読み込み、各単語について（接尾辞、単語）のペアを作成します。例えば「cat」からは、("t", "cat")、("at", "cat")、("cat", "cat")というペアが作成されます。

2. ユーザーが「cat」のような単語を入力すると、プログラムはその単語の可能な末尾を調べます：「t」、「at」、「cat」。

3. 各末尾について、プログラムはすべての接尾辞-単語ペアを検索し、同じ末尾を持つ単語を見つけます。

4. プログラムはこれらの結果を統合し、重複を除去して、元の入力単語を除外してユーザーに返します。

このアプローチは、このコースで扱われている配列と線形探索のみを使用しています。

---

## 3. 擬似コード

Cormen et al. 第2章の規約に従う：

### 3.1 接尾辞インデックスの構築

```
BUILD-SUFFIX-INDEX(words)
 1  suffixPairs = new Array
 2  for i = 1 to words.length
 3      word = words[i]
 4      for j = 1 to word.length
 5          suffix = SUBSTRING(word, word.length - j + 1, word.length)
 6          APPEND(suffixPairs, [suffix, word])
 7  return suffixPairs
```

### 3.2 韻の検索

```
FIND-RHYMES(suffixPairs, inputWord, minSuffixLength)
 1  results = new Array
 2  for j = minSuffixLength to inputWord.length
 3      targetSuffix = SUBSTRING(inputWord, inputWord.length - j + 1, inputWord.length)
 4      for i = 1 to suffixPairs.length
 5          [suffix, word] = suffixPairs[i]
 6          if suffix == targetSuffix and word ≠ inputWord
 7              if not LINEAR-SEARCH(results, word)
 8                  APPEND(results, word)
 9  return results
```

### 3.3 線形探索（重複チェック用）

```
LINEAR-SEARCH(A, target)
 1  for i = 1 to A.length
 2      if A[i] == target
 3          return true
 4  return false
```

---

## 4. データ構造

### 4.1 配列（動的配列）

**構造：** 接尾辞-単語ペアと結果を格納する順序付きリスト。

**接尾辞-単語ペア配列：**
```
[
    ["t", "cat"],
    ["at", "cat"],
    ["cat", "cat"],
    ["t", "bat"],
    ["at", "bat"],
    ["bat", "bat"],
    ...
]
```

**適している理由：**
- **コースで扱われている：** 配列はこのコースで教えられている基本的なデータ構造。
- **シンプルな保存：** すべての接尾辞-単語ペアを分かりやすい方法で保持。
- **簡単な反復処理：** 線形探索を使用した順次処理が可能。
- **動的サイズ調整：** インデックス構築時に必要に応じて拡張可能。

### 4.2 線形探索

**アルゴリズム：** 配列内を順次検索してターゲット値を見つける。

**適している理由：**
- **コースで扱われている：** 線形探索はこのコースで教えられている基本的なアルゴリズム。
- **シンプルな実装：** 理解しやすく、正しく実装しやすい。
- **ソート不要：** 接尾辞ペアを事前にソートする必要がない。

---

## 5. 時間・空間計算量

### 時間計算量

- **前処理（インデックス構築）：** O(n × m)、n = 単語数、m = 平均単語長
- **クエリ（韻検索）：** O(m × p × r)、m = 入力単語長、p = 接尾辞ペア数、r = 結果数（重複チェック用）

### 空間計算量

- **接尾辞ペア配列：** O(n × m)、各単語がm個の接尾辞-単語ペアを生成するため

---

## 6. プログラムフロー

```
1. ファイルから単語リストを読み込む
2. 接尾辞ペア配列を構築（前処理）
3. ユーザー入力を受け付ける
4. 線形探索で韻を検索
5. 結果を表示
6. ユーザーが終了するまでステップ3から繰り返す
```

---

## 7. 制限事項と改善の可能性

### 現在の制限事項

1. **スペリングベースの韻のみ：** アルゴリズムは発音ではなくスペリングで単語の末尾を照合する。「love」と「move」は似ているように見えるが韻を踏まない。

2. **ランキングなし：** 結果は韻の質（完全な韻 vs 不完全な韻）でランク付けされない。

3. **大きな結果セット：** 「-ing」のような一般的な接尾辞は数千のマッチを返す可能性がある。

4. **線形探索のオーバーヘッド：** 韻の検索と重複チェックの両方に線形探索を使用しているため、ハッシュベースのアプローチと比較してオーバーヘッドがある。

### 改善の可能性

1. **発音照合：** 発音に基づいて真の韻を見つけるために、音声アルゴリズム（SoundexやCMU発音辞書など）を使用する。

2. **結果ランキング：** 接尾辞の長さ（長いマッチ = より良い韻）や単語頻度で結果をランク付けする。

3. **結果制限：** ユーザーが最大結果数を指定したり、単語長でフィルタリングできるようにする。

4. **ハッシュベースのデータ構造の使用：** より大きなデータセットでは、HashMapとSetを使用することでO(n)の線形探索ではなくO(1)のルックアップ時間を提供できる。
