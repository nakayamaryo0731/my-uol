# Week 17: 分割統治法（Divide and Conquer）とソートアルゴリズム

## 1. 導入：なぜ高速ソートが必要か

### 換字式暗号（Substitution Cipher）の解読

- 英語の文字出現頻度の偏りを利用する → **頻度分析（Frequency Analysis）**
- 例：暗号文で最頻出の文字 → 元は `e` だと推測
- アルファベットの順列は約 **4 × 10²⁶** 通り
- バブルソート・挿入ソートは O(n²) → (4 × 10²⁶)² ≈ **10⁵³ 回の操作** → 非現実的

**→ もっと効率的なソートアルゴリズムが必要！**

---

## 2. 分割統治法 vs 縮小統治法

| | Decrease and Conquer | Divide and Conquer |
|--|--|--|
| 分割数 | **1つ**の小さい問題に縮小 | **2つ以上**の小さい問題に分割 |
| 解の構築 | 簡単な解から元の問題を解く | 各部分の解を**組み合わせて**解く |
| 共通点 | 再帰を使う、ベースケースまで簡略化 | 同じ |

- **ベースケース（base case）**：再帰の終了条件（これ以上分割不要な最も単純なケース）
- **再帰ケース（recursive case）**：自分自身を呼び出して問題を小さくしていくケース

---

## 3. クイックソート（Quick Sort）

### 基本的な仕組み

1. **ピボット（pivot）を選ぶ** — 配列の中央要素を選択
2. **分割（partition）** — ピボットの値を基準に、小さい値を左、大きい値を右に振り分ける
3. **再帰** — 左右の小さい配列それぞれにクイックソートを再帰的に適用
4. **ベースケース** — 要素が0個または1個 → そのまま返す

### 分割（Partition）の手順

新しい配列を作らず、**元の配列上でスワップ操作（in-place）**で行う：

```
配列: [9, 5, 4, 2, 1, 5]   ピボット = 4（3番目の要素）

i = 左端、j = 右端 から開始

- i の値がピボットより大きい → そこで止まる
- j の値がピボットより小さい → そこで止まる
- 両方止まったら → i と j の値をスワップ
- i を右へ、j を左へ進める
- i == j になったら分割終了
```

### ピボット選択の計算

```
pivot index = floor((leftmost index + rightmost index) / 2)
```

### 注意点

- ピボットが最大値/最小値の場合、分割が**偏る**（片側だけに全要素が集まる）
- 新しい配列は不要（in-place で操作）

---

## 4. マージソート（Merge Sort）

### マージ（Merge）手順

2つの**ソート済み**配列を1つのソート済み配列に統合する：

```
w: [1, 3, 5]    v: [2, 4, 6]    → s: [_, _, _, _, _, _]

i=1, j=1: w[1]=1 < v[1]=2  → s[1]=1, i++
i=2, j=1: w[2]=3 > v[1]=2  → s[2]=2, j++
i=2, j=2: w[2]=3 < v[2]=4  → s[3]=3, i++
...
片方が尽きたら → もう片方の残りを全部追加

結果: s = [1, 2, 3, 4, 5, 6]
```

**ポイント：両方ソート済みなので、1回のスキャンで統合できる**

### マージソートのアルゴリズム（擬似コード）

```
function mergeSort(vector):
    n = length(vector)
    if n == 1: return vector        ← ベースケース

    m = floor((n+1) / 2)           ← 中央で分割
    L = vector[1:m]                ← 左半分
    R = vector[m+1:n]              ← 右半分

    return merge(mergeSort(L), mergeSort(R))
```

### 図解：分割→マージの流れ

```
        [3, 1, 2, 5, 8, 1]          ← 分割フェーズ
        /                \
    [3, 1, 2]          [5, 8, 1]
    /      \            /      \
 [3, 1]   [2]       [5]    [8, 1]
  / \                        / \
[3] [1]                    [8] [1]    ← ベースケース（要素1個）
  \ /                        \ /
 [1, 3]   [2]       [5]    [1, 8]    ← マージフェーズ
    \      /            \      /
   [1, 2, 3]          [1, 5, 8]
        \                /
      [1, 1, 2, 3, 5, 8]             ← 完成！
```

---

## 5. クイックソート vs マージソートの比較

| | クイックソート | マージソート |
|--|--|--|
| 分割の基準 | ピボットの**値**に依存 | 値に**依存しない**（位置で半分に切る） |
| 分割フェーズ | 複雑（partition処理） | 単純（半分に切るだけ） |
| 統合フェーズ | 単純（結合するだけ） | 複雑（merge処理） |
| 新しい配列 | 不要（in-place） | **必要**（mergeで新配列作成） |
| ベースケース | 要素0個 or 1個 | 要素1個 |

---

## 6. 計算量の比較

| アルゴリズム | 時間計算量 |
|--|--|
| バブルソート | O(n²) |
| 挿入ソート | O(n²) |
| クイックソート / マージソート | **O(n log n)** |

### なぜ O(n log n) か

- 各段階で配列全体を1回走査 = n回の比較
- 問題が半分ずつ減る → **log₂(n) 段**
- 合計: n × log₂(n) = **O(n log n)**

n = 1,000,000 の場合：
- n² = 1,000,000,000,000（1兆）
- n log n ≈ 20,000,000（2千万）→ **桁違いに高速**

---

## 7. プログラミング課題：マージソートの実装

### 課題概要

- 6文字 `[r, w, e, s, h, i]` の全順列（720通り）を生成
- 英語での文字出現頻度に基づいてソート
- `frequencyOrder()` で各文字に数値を割り当て（e=6, i=5, s=4, h=3, r=2, w=1）

### 実装（merge.js）

**merge関数の残りのwhileループ：**
```javascript
while (i < m) {   // array1 の残り
    s[k] = array1[i];
    i++;
    k++;
}
while (j < n) {   // array2 の残り
    s[k] = array2[j];
    j++;
    k++;
}
```

**mergeSort関数：**
```javascript
function mergeSort(array) {
    var n = array.length;
    if (n <= 1) return array;
    var mid = Math.floor(n / 2);
    var left = array.slice(0, mid);
    var right = array.slice(mid);
    return merge(mergeSort(left), mergeSort(right));
}
```

---

## 8. 重要ポイントまとめ

1. **分割統治法**: 問題を2つ以上に分割 → 各々解く → 組み合わせる
2. **クイックソート**: ピボットの値で分割（in-place）
3. **マージソート**: 位置で半分に分割 → ソート済み配列をマージ（新配列必要）
4. **ベースケース**: 再帰の終了条件（要素1個以下）
5. **O(n log n)**: バブルソート O(n²) より桁違いに高速
6. **ピボット選択**: floor((left + right) / 2) で中央要素

---

## 練習問題と解答

### Q1: 分割統治法（Divide and Conquer）とは？
**A:** 問題を複数の小さい問題に分割し、各々の解を**組み合わせて**元の問題を解く手法

### Q2: クイックソートの動作は？（複数選択）
**A:**
- ピボットの**値**に基づいて分割される ○
- 分割後の小さいベクトルに対して再帰的に実行 ○
- 入力ベクトルに対して再帰的に実行 ×（再帰は小さいベクトルに対して）
- ピボットの**インデックス**に基づいて分割 ×（値で比較する）

### Q3: マージソートのベースケースは？
**A:** 要素1個のベクトル（既にソート済み）

### Q4: マージソートでの入力ベクトルの分割回数は？
**A:**
- 毎回2つに分割される
- 要素数と同じ数のベクトルになるまで続く
